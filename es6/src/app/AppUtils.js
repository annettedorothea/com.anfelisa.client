// noinspection JSUnresolvedVariable

/********************************************************************************
 * generated by de.acegen 1.3.0
 ********************************************************************************/


import * as App from "../index";

import EventListenerRegistrationCategory from "../../gen/category/EventListenerRegistration";
import EventListenerRegistrationCard from "../../gen/card/EventListenerRegistration";
import EventListenerRegistrationBox from "../../gen/box/EventListenerRegistration";
import EventListenerRegistrationCommon from "../../gen/common/EventListenerRegistration";
import EventListenerRegistrationProfile from "../../gen/profile/EventListenerRegistration";
import EventListenerRegistrationRegistration from "../../gen/registration/EventListenerRegistration";
import EventListenerRegistrationLogin from "../../gen/login/EventListenerRegistration";
import EventListenerRegistrationPassword from "../../gen/password/EventListenerRegistration";
import {
    displaySaveBugDialog,
    displayToast,
    displayVersionMismatchDialog,
    displayVersionMismatchErrorDialog,
    init,
    routeChanged,
} from "../../gen/common/ActionFunctions";
import CryptoJS from "crypto-js";
import {dumpTimeline} from "../../gen/ace/Timeline";
import {RootContainer, setRootContainerState} from "../components/RootContainer";
import React from "react";
import ReactDOM from "react-dom";
import * as R from 'ramda'

let appState = {};

export function get(path) {
    const lens = R.lensPath(path);
    return R.view(lens, appState);
}

export function getHash() {
    return location.hash;
}

export function getStorage(path) {
    return localStorage.getItem(R.last(path));
}

function normalizeData(data, path, attributes) {
    const value = data[R.last(path)];
    if (!value) {
        return value;
    }
    if (attributes) {
        return R.pick(attributes, data[R.last(path)]);
    } else {
        return data[R.last(path)]
    }
}

function verifyGroups(groupVerifications) {
    if (!groupVerifications) {
        return true;
    }
    for(let i=0; i<groupVerifications.length; i++) {
        const groupVerification = groupVerifications[i];
        const groupInAppState = get(groupVerification.path)
        if (groupInAppState.group !== groupVerification.group) {
            return false;
        }
    }
    return true;
}

export function set(data, path, groupVerifications, attributes) {
    if (verifyGroups(groupVerifications) === false) {
        return;
    }
    const normalizedData = normalizeData(data, path, attributes);
    const lens = R.lensPath(path);
    appState = R.set(lens, normalizedData, appState);
}

export function setHash(data, path) {
    location.hash = data[R.last(path)];
}

export function setStorage(data, path) {
    const lastParam = R.last(path);
    if (data[lastParam]) {
        localStorage.setItem(lastParam, data[lastParam]);
    } else {
        localStorage.removeItem(lastParam);
    }
}

export function merge(data, path, groupVerifications, attributes) {
    if (verifyGroups(groupVerifications) === false) {
        return;
    }
    if (attributes) {
        const lens = R.lensPath(path);
        const appStateValue = R.view(lens, appState);
        const normalizedData = normalizeData(data, path, attributes);
        const mergedData = R.mergeDeepRight(appStateValue, normalizedData);
        appState = R.set(lens, mergedData, appState);
    } else {
        set(data, path, attributes);
    }
}

export function mergeHash(data, path) {
    if (data[R.last(path)]) {
        location.hash = data[R.last(path)];
    }
}

export function mergeStorage(data, path) {
    const lastParam = R.last(path);
    if (data[lastParam]) {
        localStorage.setItem(lastParam, data[lastParam]);
    }
}

export function createInitialAppState() {
    appState = {};
}


export let settings;

function loadSettings() {
    return httpGet("settings.json").then((loadedSettings) => {
        settings = loadedSettings;
        if (!settings.clientVersion) {
            settings.clientVersion = "";
        }
        if (!settings.aceScenariosApiKey) {
            settings.aceScenariosApiKey = "";
        }
        if (!settings.aceScenariosBaseUrl) {
            settings.aceScenariosBaseUrl = "";
        }
        if (!settings.rootPath) {
            settings.rootPath = "";
        }
        if (!settings.timelineSize) {
            settings.timelineSize = 0;
        }
        if (!settings.mode) {
            settings.mode = "live";
        }
        if (settings.rootPath.startsWith("/")) {
            settings.rootPath = settings.rootPath.substring(1);
        }
        if (settings.rootPath.endsWith("/")) {
            settings.rootPath = settings.rootPath.substring(0, settings.rootPath.length - 1);
        }
    });
}

export function initEventListeners() {
    EventListenerRegistrationCategory.init();
    EventListenerRegistrationCard.init();
    EventListenerRegistrationBox.init();
    EventListenerRegistrationCommon.init();
    EventListenerRegistrationProfile.init();
    EventListenerRegistrationRegistration.init();
    EventListenerRegistrationLogin.init();
    EventListenerRegistrationPassword.init();
}

export function startApp() {
    window.onhashchange = () => {
        routeChanged();
        window.scrollTo(0, 0);
    };
    loadSettings().then(() => {
        init(location.hash, localStorage.getItem("username"), localStorage.getItem("password"));
    });
    setInterval(() => {
        const currentVersion = settings.clientVersion;
        loadActualClientVersion().then((actualClientVersion) => {
            if (actualClientVersion !== currentVersion) {
                displayVersionMismatchDialog();
            }
        });
    }, 300 * 1000);
}

function loadActualClientVersion() {
    return httpRequest("GET", "settings.json").then((settings) => {
        return settings.clientVersion;
    })
}

export function startReplay() {
    window.onhashchange = () => {
    };
}

function createHeaders(authorize) {
    const headers = new Headers();
    headers.append("Content-Type", "application/json");
    headers.append("Accept", "application/json");
    if (authorize === true) {
        let authorization = basicAuth();
        if (authorization !== undefined) {
            headers.append("Authorization", authorization);
        }
    }
    return headers;
}

function addUuidToUrl(url, uuid) {
    if (uuid) {
        if (url.indexOf("?") < 0) {
            url += "?uuid=" + uuid;
        } else {
            url += "&uuid=" + uuid;
        }
    }
    return url;
}

function httpRequest(methodType, url, uuid, authorize, data) {
    return new Promise((resolve, reject) => {
        const options = {
            method: methodType,
            headers: createHeaders(authorize),
            mode: 'cors',
            cache: 'no-cache'
        };
        if (data && methodType !== "GET") {
            options.body = JSON.stringify(data);
        }
        url = addUuidToUrl(url, uuid);
        const request = new Request(url, options);

        fetch(request).then(function (response) {
            response.text().then((text) => {
                if (response.status >= 300) {
                    const error = createError(text, response.statusText, response.status);
                    reject(error);
                } else {
                    let data = {};
                    if (text.length > 0) {
                        data = JSON.parse(text);
                    }
                    resolve(data);
                }
            });
        }).catch(function (error) {
            reject(createError(error, error));
        });
    });
}

export function httpGet(url, uuid, authorize) {
    return httpRequest("GET", url, uuid, authorize, null);
}

export function httpPost(url, uuid, authorize, data) {
    return httpRequest("POST", url, uuid, authorize, data);
}

export function httpPut(url, uuid, authorize, data) {
    return httpRequest("PUT", url, uuid, authorize, data);
}

export function httpDelete(url, uuid, authorize, data) {
    return httpRequest("DELETE", url, uuid, authorize, data);
}

function basicAuth() {
    const username = get(["rootContainer", "loggedInUser", "username"]);
    const password = get(["rootContainer", "loggedInUser", "password"]);
    // noinspection JSUnresolvedVariable
    if (username !== undefined && password !== undefined) {
        const wordArray = CryptoJS.enc.Utf8.parse(username + ':' + password);
        const hash = CryptoJS.enc.Base64.stringify(wordArray);
        return "anfelisaBasic " + hash;
    }
    return undefined;
}

export function createUUID() {
    let d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}

export function displayUnexpectedError(error) {
    console.error("unexpected error", error);
    const currentVersion = settings.clientVersion;
    App.dumpAppState();
    dumpTimeline();
    loadActualClientVersion().then((actualClientVersion) => {
        if (actualClientVersion !== currentVersion) {
            displayVersionMismatchErrorDialog();
        } else {
            if (typeof error !== "object") {
                displayToast({}, createError("unknownError", error));
            } else {
                displayToast({}, normalizeError(error));
            }
            displaySaveBugDialog();
        }
    });
}

function normalizeError(error) {
    return {
        code: error.code ? error.code : 0,
        text: error.text ? error.text : "unknownError",
        textKey: error.textKey ? error.textKey : error.code && error.code === 401 ? "loginFailed" : "unknownError",
        type: "error"
    }
}


export function deepCopy(object) {
    return R.clone(object);
}

export function stateUpdated() {
    setRootContainerState(appState.rootContainer);
}

export function renderApp() {
    let container = <RootContainer {...appState} />;
    ReactDOM.render(
        container,
        document.getElementById('root')
    );
}

export function createInfoMessage(textKey) {
    return {
        textKey,
        type: "info"
    }
}

export function createError(textKey, text, code) {
    return {
        code,
        text,
        textKey: code && code === 401 ? "loginFailed" : textKey,
        type: "error"
    }
}

export function isUnauthorized(message) {
    return (message && message.code && message.code === 401);
}



/******* S.D.G. *******/



